## 题意

给出一些名字以及他们之间的通话时长，求每个团伙的人数以及老大。

## 思路

名字可以看作点，通话时长看作点与点之间的线长度，那么就构成了一个图。团伙是满足一定条件的点集。  
一开始可能会想到并查集。其实并查集也可以解决，不过不大方便，因为这道题要求的不只是点集的个数，还要求每个点集有多少个点。  
所以不妨在每个点集中进行DFS，这样就可以遍历出点集中所有的点，计算出总个数、总边权，这样就可以判断是否满足一个gang的要求，还可以输出最大点权（gang老大）。

## 关键点

* 数据结构。比如点的权重，要用string作为key，可以用map<string, int>。当然题目也给了一些提示，说名字是从AAA到ZZZ的字符串，那么其实我们可以hash到26进制上，即A是0，Z是25，那么AAA～ZZZ就是0～17575（26^3 - 1），就是有点浪费空间了，倒不如直接用map，还更方便。

* 还是数据结构。遍历一个点集的时候，需要提前存储点与点之间连通的信息，一般我们会用二维数组，对应到这里就是二重map即：
```c++
map< string, map<string, int> > graph;
```
不过，这道题中我们只需要知道一个点的邻接点有哪些，而不需要知道它们之间的边的权重，所以我们可以用类似邻接链表的结构就足够了：
```c++
map< string, vector<string> > adjacent;
```

* 总边权的求法：如果A、B之间的边权重为10，那么A的点权重加上10，B也加上10，如此一来，最后这个点集的总的边权便等于总的点权的一半。所以我们不必同时存储边权和点权。

