## 题意

输出最短路径中、符合一定条件的那条。

## 思路

单源最短路径，可以用Dijkstra。  

* 如果最短路径只有一条，那么可以使用一个数组来记录每一个点的上一个点，在进行「松弛」的时候更新。
```c++
int last[N]; // 比如last[2]=4，表示2的上一个点是4，即这段路径是4->2
```
&emsp;&emsp;最后把这个数组逆序拼接成一条完整的最短路。  

  
* 如果有多条路径需要记录下来，那个int数组就不行了，可以改用：
```c++
vector<int> last[N]; // 比如last[3] = vector(2,5,6)，表明3这一点有三个前驱点，分别是2、5、6。
```
&emsp;&emsp;遍历多条路径，可以使用DFS。  

#### ——多条最短路径的情况，为什么用DFS来遍历？是怎么想到用DFS的？
 > 多条路径，实际上是对应了“一个点有多个前驱点”的情况。而如果逆向看，假设是一个点有多个后继点，那其实就是“树”的结构了（N叉树）。
 所以把终点看成root之后，形成一棵树（这棵树的结点是有重复的、比如叶子），树的叶子结点就是起点。然后，对它进行DFS，从root到达每一个leaf node，走过的地方就形成一条最短路径了。
