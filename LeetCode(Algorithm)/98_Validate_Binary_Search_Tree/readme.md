## 题意

判断一棵树是不是“二叉搜索树（BST）”。

## 思路

其实思路在题目描述中已经给出来了：
* 左子树所有节点都要比root小
* 右子树所有节点都要比root大
* 递归地，左右子树也都必须是BST  

举个例子，比如下面这棵树就不是BST了：
```
         10
        /  \
       5    15
           /  \
          6    20
```
为什么呢？因为对于整棵树的root来说，它的右子树存在一个更小的数字6，所以并不符合BST的条件（具体是第2个条件）。于是我们可以得到代码思路（类似于后序。BTW.后序的DFS总是那么有用、常见）：  
```
对于某一个节点node来说：
1.判断以node->left为根节点的这棵子树（简称"node->left树"）是不是BST，同时获取node->left树中最大的点maxVal。
2.同上，判断node->right树是否是BST，同时获取其最小的点minVal。
3.最后，如果有: maxVal < node->val 且 minVal > node->val，那么这个“node树”就是一个BST了。
（在这个过程中，哪个因素不满足，就可以终止DFS，宣告并不是一个BST了——所以可以用一个全局的bool变量来控制DFS的终止或继续）
```
具体代码，可以参考我的代码：answer.cpp。
