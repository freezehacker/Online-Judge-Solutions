典型的“增加、查询”的题目，如果查询Q和条目I的关系满足：Q>>I时（也是通常情况），不妨先做好预处理：提前求出所有条目的信息，待查询的时候就不用耗费时间去找了，特别是对于重复的关键字的查询更有用。这道题，如果等到查询的时候再去慢慢搜索，好像也能AC，也许是测例比较仁慈。

另外，为了省内存，我尽量不使用结构体本身，而是使用指针。所以最后需要delete，如果不记得就会发生内存泄漏了。这是使用指针要注意的地方。

具体到题目来说，我的思路是：
（1）因为要求学生的4个科目里面排名最高的一科，我维护了4个vector，分别对应4个科目的学生排名，然后分别按照每一科来进行（降序）排序。如此一来，对于每一个学生，每一科的排名就是下标值+1（当然，这里不一定是下标+1，需要考虑相同分数的情况）。
（2）遍历地求出每一个学生的最佳排名和学科情况后，建立一个map<int, string>，即id到成绩的mapping，目的也是通过以空间换时间，在查询的时候达到O(1)的时间复杂度。（当然，map的内部实现，肯定不是O(1)的复杂度），不必每次都去遍历整个结果集了。
