## 题意

经典题，判断单链表有没有环

## 思路

有三种不同的方法：
* 给走过的节点加上一些标志，走到了被标记的节点，说明已经来过了，也就是有环。因为struct中没有留一个备用的标志位，所以我只能把val改成一个某个值。这种方法是最不好的，一是改变了单链表的value，二是这个“某个值”不能确定。  
  * 时间复杂度：O(n)。因为每个节点的判断，只是简单地看标志变量，即O(1)。
  * 空间复杂度：O(1)；或认为是O(n)，因为被改变的入参也算作辅助空间
  * 代码：answer_bad_answer.cpp
* 相当于上面方法的一个改进版：用map（对应Java中Hashmap）来记住走过的节点的地址，每次走到一个节点，查看该地址是否已经在map之中。
  * 时间复杂度：O(nlogn)——因为在map中增加、查找一个地址需要logn时间复杂度
  * 空间复杂度：O(n)
  * 代码：answer_ok_version.cpp
* 两个指针法：设置一个每次走1步(slow)和每次走2步的指针(fast)，不断地走。如果fast走到了NULL即链表结尾，表明不存在环；如果fast与slow在某一时刻相遇（除了一开始都在head），那么说明存在环。
  * 时间复杂度：O(kn) = O(n)，k为常数。
  * 空间复杂度：O(1)
  * 代码：answer_good_version.cpp

## 拓展思考

在test我的代码的时候发现，有环链表的destructor跟一般的不一样。  
一般我们destroy一个单链表，要么用递推，要么用递归（DFS），这两种都基于一个前提就是以NULL结尾，即不存在环。  
那么怎么destroy一个有环链表呢？我们可以借用上面的第2种思路，把所有节点的地址用map记录起来（记录的时候，遇到环，记录过程就结束了），然后遍历这个map，delete所有address，就可以把所有地址对应的对象都释放掉。
